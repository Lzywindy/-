<!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title>&#x6D4B;&#x91CF;&#x5BC4;&#x5B58;&#x5668;</title>
        <style>
</style>
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css" integrity="sha384-yFRtMMDnQtDRO8rLpMIKrtPCD5jdktao2TV19YiZYWMDkUR5GQZR/NOVTdquEx1j" crossorigin="anonymous">
<link href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css" rel="stylesheet" type="text/css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        <style>
.task-list-item { list-style-type: none; } .task-list-item-checkbox { margin-left: -20px; vertical-align: middle; }
</style>
        
        <script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script>
        
    </head>
    <body class="vscode-body vscode-light">
        <h1 id="测量寄存器">测量寄存器</h1>
<h2 id="函数-measurecolor">函数 MeasureColor</h2>
<p>测量量程寄存器的内容并将其转换为颜色（整数）。</p>
<h3 id="输入">输入</h3>
<ul>
<li>
<p>register</p>
<p>要测量的量子位寄存器。</p>
</li>
</ul>
<h3 id="代码">代码</h3>
<pre><code class="language-javascript"><div>operation MeasureColor (register : Qubit[]) : Int {
    <span class="hljs-keyword">return</span> MeasureInteger(LittleEndian(register));
}
</div></code></pre>
<h2 id="函数-measurecoloring">函数 MeasureColoring</h2>
<p>从寄存器中读取颜色。</p>
<h3 id="输入-1">输入</h3>
<ul>
<li>
<p>bitsPerColor</p>
<p>每种颜色的位数。</p>
</li>
<li>
<p>register</p>
<p>要测量的量子位寄存器。</p>
</li>
</ul>
<h3 id="代码-1">代码</h3>
<pre><code class="language-javascript"><div>operation MeasureColoring (bitsPerColor : Int, <span class="hljs-attr">register</span> : Qubit[]) : Int[] {
    <span class="hljs-keyword">let</span> numVertices = Length(register) / bitsPerColor;
    <span class="hljs-keyword">let</span> colorPartitions = Partitioned(ConstantArray(numVertices - <span class="hljs-number">1</span>, bitsPerColor), register);
    <span class="hljs-keyword">return</span> ForEach(MeasureColor, colorPartitions);
}
</div></code></pre>
<h2 id="函数-applycolorequalityoracle">函数 ApplyColorEqualityOracle</h2>
<p>N位颜色等价oracle（无需额外的量子位）</p>
<h3 id="输入-2">输入</h3>
<ul>
<li>
<p>color0</p>
<p>第一个颜色。</p>
</li>
<li>
<p>color1</p>
<p>第二个颜色。</p>
</li>
</ul>
<h3 id="输出">输出</h3>
<p>两个颜色一样，则输出为1。</p>
<h3 id="代码-2">代码</h3>
<pre><code class="language-javascript"><div>operation ApplyColorEqualityOracle (color0 : Qubit[], <span class="hljs-attr">color1</span> : Qubit[], <span class="hljs-attr">target</span> : Qubit) : Unit is Adj+Ctl {
    within {
        <span class="hljs-keyword">for</span> ((q0, q1) <span class="hljs-keyword">in</span> Zip(color0, color1)) {
            <span class="hljs-comment">//q1&lt;=q0 XOR q1</span>
            CNOT(q0, q1);
        }
    } apply {
        <span class="hljs-comment">//如果观测出来全为0，则表示两个寄存器中的值相等</span>
        (ControlledOnInt(<span class="hljs-number">0</span>, X))(color1, target);
    }
}
</div></code></pre>
<h2 id="函数-applyvertexcoloringoracle">函数 ApplyVertexColoringOracle</h2>
<p>验证顶点着色的<code>Oracle</code>，包括非量子位顶点的颜色约束。</p>
<h3 id="输入-3">输入</h3>
<ul>
<li>
<p>numVertices</p>
<p>图中顶点的数目。</p>
</li>
<li>
<p>bitsPerColor</p>
<p>每种颜色的位数，例如每种颜色2位，允许4种颜色。</p>
</li>
<li>
<p>edges</p>
<p>（Vertex#，Vertex#）数组，指定不同颜色的顶点。</p>
</li>
<li>
<p>startingColorConstraints</p>
<p>指定顶点不允许的颜色的数组（Vertex#，Color）。</p>
</li>
</ul>
<h3 id="输出-1">输出</h3>
<p>如果控制寄存器状态与位掩码<code>bits</code>相对应，则对目标寄存器应用<code>oracle</code>操作。</p>
<h3 id="代码-3">代码</h3>
<pre><code class="language-javascript"><div>operation ApplyVertexColoringOracle (numVertices : Int, <span class="hljs-attr">bitsPerColor</span> : Int, <span class="hljs-attr">edges</span> : (Int, Int)[],  
    <span class="hljs-attr">startingColorConstraints</span> : (Int, Int)[], 
    <span class="hljs-attr">colorsRegister</span> : Qubit[], 
    <span class="hljs-attr">target</span> : Qubit) : Unit is Adj+Ctl {
    <span class="hljs-keyword">let</span> nEdges = Length(edges);
    <span class="hljs-keyword">let</span> nStartingColorConstraints = Length(startingColorConstraints);
    <span class="hljs-comment">// 我们正在寻找一种解决方案：</span>
    <span class="hljs-comment">// (a) 没有两端颜色相同的边 </span>
    <span class="hljs-comment">// (b) 没有颜色违反起始颜色约束的顶点</span>
    using ((edgeConflictQubits, startingColorConflictQubits) = (Qubit[nEdges], Qubit[nStartingColorConstraints])) {
        within {
            ConstrainByEdgeAndStartingColors(colorsRegister, edges, startingColorConstraints, edgeConflictQubits, startingColorConflictQubits, bitsPerColor);
        } apply {
            <span class="hljs-comment">// 如果没有冲突（所有量子位都处于0状态），则顶点着色是有效的。</span>
            (ControlledOnInt(<span class="hljs-number">0</span>, X))(edgeConflictQubits + startingColorConflictQubits, target);
        }
    }
}
<span class="hljs-comment">//按边和起始颜色约束进行约束</span>
operation ConstrainByEdgeAndStartingColors (colorsRegister : Qubit[], <span class="hljs-attr">edges</span> : (Int, Int)[], <span class="hljs-attr">startingColorConstraints</span> : (Int, Int)[],
    <span class="hljs-attr">edgeConflictQubits</span> : Qubit[], <span class="hljs-attr">startingColorConflictQubits</span> : Qubit[], <span class="hljs-attr">bitsPerColor</span>: Int): Unit is Adj+Ctl {
    <span class="hljs-keyword">for</span> (((start, end), conflictQubit) <span class="hljs-keyword">in</span> Zip(edges, edgeConflictQubits)) {
        <span class="hljs-comment">// 检查边的端点是否具有不同的颜色：</span>
        <span class="hljs-comment">// 应用ColorEqualityOracle_Nbit `oracle`；</span>
        <span class="hljs-comment">// 如果颜色相同，结果为1，表示冲突</span>
        ApplyColorEqualityOracle(
            colorsRegister[start * bitsPerColor .. (start + <span class="hljs-number">1</span>) * bitsPerColor - <span class="hljs-number">1</span>], colorsRegister[end * bitsPerColor .. (end + <span class="hljs-number">1</span>) * bitsPerColor - <span class="hljs-number">1</span>], conflictQubit);
    }
    <span class="hljs-keyword">for</span> (((cell, value), conflictQubit) <span class="hljs-keyword">in</span>
        Zip(startingColorConstraints, startingColorConflictQubits)) {
        <span class="hljs-comment">// 检查单元格是否与起始颜色冲突。</span>
        (ControlledOnInt(value, X))(colorsRegister[
            cell * bitsPerColor .. (cell + <span class="hljs-number">1</span>) * bitsPerColor - <span class="hljs-number">1</span>], conflictQubit);
    }

}

</div></code></pre>
<h3 id="举个例子">举个例子</h3>
<p>这是个 4x4 的数独谜题：</p>
<pre><code><code><div>    -----------------
    |   |   | 2 | 3 |
    -----------------
    |   |   | 0 | 1 |
    -----------------
    | 1 | 2 | 3 | 0 |
    -----------------
    | 3 | 0 | 1 | 2 |
    -----------------
</div></code></code></pre>
<p>挑战是用0到3的数字填充空正方形，这些数字在行、列和左上角2x2平方中是唯一的。这是一个图着色问题，其中颜色为0到3，空单元格是顶点。顶点可以定义为：</p>
<pre><code><code><div>    -----------------
    | 0 | 1 |   |   |
    -----------------
    | 2 | 3 |   |   |
    -----------------
    |   |   |   |   |
    -----------------
    |   |   |   |   |
    -----------------

图可以表示为这个

 0---1
 | X |
 1---2
</div></code></code></pre>
<p>i.e. every vertex is connected to each other.
Additionally, we require that:</p>
<ul>
<li>vertices 0 and 1 do not get colors 2 and 3.</li>
<li>vertices 2 and 3 do not get colors 3 and 0.</li>
<li>vertices 0 and 2 do not get colors 1 and 3.</li>
<li>vertices 1 and 3 do not get colors 2 and 0.</li>
</ul>
<p>This results in edges (vertices that can not be same color):
<code>edges = [(1, 0),(2, 0),(3, 0),(3, 1),(3, 2)]</code></p>
<p>This is saying that vertex 1 can not have same color as vertex 0 etc.</p>
<p>and startingColorConstraints = [(0, 1),(0, 3),(0, 2),(1, 2),(1, 0),(1, 3),(2, 1),(2, 3),(2, 0),(3, 2),(3, 0),(3, 1)]</p>
<p>This is saying that:</p>
<ul>
<li>vertex 0 is not allowed to have values 1,3,2</li>
<li>vertex 1 is not allowed to have values 2,0,3</li>
<li>vertex 2 is not allowed to have values 1,3,0</li>
<li>vertex 3 is not allowed to have values 2,0,1</li>
</ul>
<p>A valid graph coloring solution is: [0,1,2,3] i.e. vextex 0 has color 0, vertex 1 has color 1 etc.</p>
<h1 id="summary">Summary</h1>
<p>Oracle for verifying vertex coloring, including color constraints
from non qubit vertices. This is the same as ApplyVertexColoringOracle,
but hardcoded to 4 bits per color and restriction that colors are
limited to 0 to 8.</p>
<h1 id="input">Input</h1>
<h2 id="numvertices">numVertices</h2>
<p>The number of vertices in the graph.</p>
<h2 id="edges">edges</h2>
<p>The array of (Vertex#,Vertex#) specifying the Vertices that can not
be the same color.</p>
<h2 id="startingcolorconstraints">startingColorConstraints</h2>
<p>The array of (Vertex#,Color) specifying the dissallowed colors for vertices.</p>
<h2 id="colorsregister">colorsRegister</h2>
<p>The color register.</p>
<h2 id="target">target</h2>
<p>The target of the operation.</p>
<h1 id="output">Output</h1>
<p>A unitary operation that applies <code>oracle</code> on the target register if the control
register state corresponds to the bit mask <code>bits</code>.</p>
<h1 id="example">Example</h1>
<p>Consider the following 9x9 Sudoku puzzle:</p>
<pre><code><code><div>   -------------------------------------
   |   | 6 | 2 | 7 | 8 | 3 | 4 | 0 | 1 |
   -------------------------------------
   | 8 |   | 1 | 6 | 2 | 4 | 3 | 7 | 5 |
   -------------------------------------
   | 7 | 3 | 4 | 5 | 0 | 1 | 8 | 6 | 2 |
   -------------------------------------
   | 6 | 8 | 7 | 1 | 5 | 0 | 2 | 4 | 3 |
   -------------------------------------
   | 4 | 1 | 5 | 3 | 6 | 2 | 7 | 8 | 0 |
   -------------------------------------
   | 0 | 2 | 3 | 4 | 7 | 8 | 1 | 5 | 6 |
   -------------------------------------
   | 3 | 5 | 8 | 0 | 1 | 7 | 6 | 2 | 4 |
   -------------------------------------
   | 1 | 7 | 6 | 2 | 4 | 5 | 0 | 3 | 8 |
   -------------------------------------
   | 2 | 4 | 0 | 8 | 3 | 6 | 5 | 1 | 7 |
   -------------------------------------
</div></code></code></pre>
<p>The challenge is to fill the empty squares with numbers 0 to 8
that are unique in row, column and the top left 3x3 square
This is a graph coloring problem where the colors are 0 to 8
and the empty cells are the vertices. The vertices can be defined as</p>
<pre><code><code><div>    -----------------
    | 0 |   |   |   | ...
    -----------------
    |   | 1 |   |   | ...
    -----------------
    |   |   |   |   | ...
    ...
</div></code></code></pre>
<p>The graph is</p>
<pre><code><code><div>    0---1 
</div></code></code></pre>
<p>Additionally, we also require that</p>
<ul>
<li>vertex 0 can not have value 6,2,7,8,3,4,0,1 (row constraint)
or value 8,7,6,4,0,3,1,2 (col constraint)</li>
<li>vertex 1 can not value 8,1,6,2,4,3,7,5 (row constraint)
or value 6,3,8,1,2,5,7,4 (col constraint)
This results in edges (vertices that can not be same color)
edges = [(1, 0)]
This is saying that vertex 1 can not have same color as vertex 0
and startingColorConstraints = [(0, 8),(0, 7),(0, 6),(0, 4),(0, 0),(0, 3),
(0, 1),(0, 2),(1, 6),(1, 3),(1, 8),(1, 1),(1, 2),(1, 5),(1, 7),(1, 4)]
The colors found must be from 0 to 8, which requires 4 bits per color.
A valid graph coloring solution is: [5,0]
i.e. vextex 0 has color 5, vertex 1 has color 0.</li>
</ul>
<h3 id="代码-4">代码</h3>
<pre><code class="language-javascript"><div>operation ApplyVertexColoringOracle4Bit9Color (numVertices : Int, <span class="hljs-attr">edges</span> : (Int, Int)[],  <span class="hljs-attr">startingColorConstraints</span> : (Int, Int)[], <span class="hljs-attr">colorsRegister</span> : Qubit[], <span class="hljs-attr">target</span> : Qubit) : Unit is Adj+Ctl {
    <span class="hljs-keyword">let</span> nEdges = Length(edges);
    <span class="hljs-keyword">let</span> bitsPerColor = <span class="hljs-number">4</span>; <span class="hljs-comment">// 4 bits per color</span>
    <span class="hljs-keyword">let</span> nStartingColorConstraints = Length(startingColorConstraints);
    <span class="hljs-comment">// we are looking for a solution that:</span>
    <span class="hljs-comment">// (a) has no edge with same color at both ends and </span>
    <span class="hljs-comment">// (b) has no Vertex with a color that violates the starting color constraints.</span>
    using ((edgeConflictQubits, startingColorConflictQubits, vertexColorConflictQubits) = 
        (Qubit[nEdges], Qubit[nStartingColorConstraints], Qubit[numVertices])) {
        within {
            ConstrainByEdgeAndStartingColors(colorsRegister, edges, startingColorConstraints, 
                edgeConflictQubits, startingColorConflictQubits, bitsPerColor);
            <span class="hljs-keyword">let</span> zippedColorAndConfictQubit = Zip(
                Partitioned(ConstantArray(numVertices, bitsPerColor), colorsRegister),
                vertexColorConflictQubits);
            <span class="hljs-keyword">for</span> ((color, conflictQubit) <span class="hljs-keyword">in</span> zippedColorAndConfictQubit) {
                <span class="hljs-comment">// Only allow colors from 0 to 8 i.e. if bit #3 = 1, then bits 2..0 must be 000.</span>
                using (tempQubit = Qubit()) {
                    within {
                        ApplyOrOracle(color[<span class="hljs-number">0</span> .. <span class="hljs-number">2</span>], tempQubit);
                    } apply{
                        <span class="hljs-comment">// AND color&#x27;s most significant bit with OR of least significant bits. </span>
                        <span class="hljs-comment">// This will set conflictQubit to 1 if color &gt; 8.</span>
                        CCNOT(color[<span class="hljs-number">3</span>], tempQubit, conflictQubit);
                    }
                }
            }
        } apply {
            <span class="hljs-comment">// If there are no conflicts (all qubits are in 0 state), the vertex coloring is valid.</span>
            (ControlledOnInt(<span class="hljs-number">0</span>, X))(edgeConflictQubits + startingColorConflictQubits + vertexColorConflictQubits, target);
        }
    }
}
</div></code></pre>
<h2 id="函数-applyororacle">函数 ApplyOrOracle</h2>
<p>用于查询寄存器中任意数量的量子位的OR oracle。</p>
<h3 id="输入-4">输入</h3>
<ul>
<li>
<p>queryRegister</p>
<p>要查询的Qubit寄存器。</p>
</li>
<li>
<p>target</p>
<p>用于存储oracle结果的目标量子位。</p>
</li>
</ul>
<h3 id="代码-5">代码</h3>
<pre><code class="language-javascript"><div>operation ApplyOrOracle (queryRegister : Qubit[], <span class="hljs-attr">target</span> : Qubit) : Unit is Adj {
    <span class="hljs-comment">// x₀ ∨ x₁ = ¬ (¬x₀ ∧ ¬x₁)</span>
    <span class="hljs-comment">// 首先，如果两个量子位都处于| 0⟩状态，则翻转目标。</span>
    (ControlledOnInt(<span class="hljs-number">0</span>, X))(queryRegister, target);
    <span class="hljs-comment">// 然后再次翻转目标取反。</span>
    X(target);
}
</div></code></pre>
<h2 id="函数-findcolorswithgrover">函数 FindColorsWithGrover</h2>
<p>用Grover的搜索寻找顶点着色。</p>
<h3 id="输入-5">输入</h3>
<ul>
<li>
<p>numVertices</p>
<p>图中顶点的数目。</p>
</li>
<li>
<p>bitsPerColor</p>
<p>每种颜色的位数。</p>
</li>
<li>
<p>maxIterations</p>
<p>估计所需的最大迭代次数。</p>
</li>
<li>
<p>oracle</p>
<p>用于寻找解的<code>oracle</code></p>
</li>
</ul>
<h3 id="输出-2">输出</h3>
<p>提供每个顶点颜色的Int数组。</p>
<h3 id="提示">提示</h3>
<p>SolveSATWithGrover Kata中的原始实现请查看[<a href="https://github.com/microsoft/QuantumKatas/tree/main/SolveSATWithGrover">https://github.com/microsoft/QuantumKatas/tree/main/SolveSATWithGrover</a>]。</p>
<h3 id="代码-6">代码</h3>
<pre><code class="language-javascript"><div>operation FindColorsWithGrover (numVertices : Int, <span class="hljs-attr">bitsPerColor</span> : Int, <span class="hljs-attr">maxIterations</span> : Int,<span class="hljs-attr">oracle</span> : (<span class="hljs-function">(<span class="hljs-params">Qubit[], Qubit</span>) =&gt;</span> Unit is Adj)) : Int[] {
    <span class="hljs-comment">// 此任务类似于SolveSATWithGrover kata的2.2版本，</span>
    <span class="hljs-comment">// 但正确解决方案的百分比可能更高。</span>
    mutable coloring = <span class="hljs-keyword">new</span> Int[numVertices];

    <span class="hljs-comment">// 注意，着色寄存器的量子比特数是顶点数的两倍</span>
    <span class="hljs-comment">//（每个顶点的比特数或量子比特数）。</span>
    using ((register, output) = (Qubit[bitsPerColor * numVertices], Qubit())) {
        mutable correct = <span class="hljs-literal">false</span>;
        mutable iter = <span class="hljs-number">1</span>;
        <span class="hljs-comment">// 尝试一次迭代，如果失败，则再次尝试一次迭代并重复，</span>
        <span class="hljs-comment">// 直到达到最大迭代次数。</span>
        repeat {
            Message($<span class="hljs-string">&quot;Trying search with {iter} iterations...&quot;</span>);
            ApplyGroversAlgorithmLoop(register, oracle, iter);
            <span class="hljs-keyword">let</span> res = MultiM(register);
            <span class="hljs-comment">// 若要检查结果是否正确，请在测量后对寄存器加辅助项应用oracle。</span>
            oracle(register, output);
            <span class="hljs-keyword">if</span> (MResetZ(output) == One) {
                set correct = <span class="hljs-literal">true</span>;
                <span class="hljs-comment">// 读出颜色。</span>
                set coloring = MeasureColoring(bitsPerColor, register);
            }
            ResetAll(register);
        } until (correct or iter &gt; maxIterations)  
        fixup {
            set iter += <span class="hljs-number">1</span>;
        }
        <span class="hljs-keyword">if</span> (not correct) {
            fail <span class="hljs-string">&quot;Failed to find a coloring.&quot;</span>;
        }
    }
    <span class="hljs-keyword">return</span> coloring;
}
</div></code></pre>
<h2 id="函数-applyphaseoracle">函数 ApplyPhaseOracle</h2>
<p>Grover算法迭代循环</p>
<h3 id="输入-6">输入</h3>
<ul>
<li>
<p>oracle</p>
<p><code>Oracle</code>将标记有效的解决方案。</p>
</li>
</ul>
<h3 id="提示-1">提示</h3>
<p>SolveSATWithGrover Kata中的原始实现请查看[<a href="https://github.com/microsoft/QuantumKatas/tree/main/SolveSATWithGrover">https://github.com/microsoft/QuantumKatas/tree/main/SolveSATWithGrover</a>]。</p>
<h3 id="代码-7">代码</h3>
<pre><code class="language-javascript"><div>operation ApplyPhaseOracle (oracle : (<span class="hljs-function">(<span class="hljs-params">Qubit[], Qubit</span>) =&gt;</span> Unit is Adj), <span class="hljs-attr">register</span> : Qubit[]) : Unit is Adj {

    using (target = Qubit()) {
        within {
            <span class="hljs-comment">// 将目标置于|-⟩状态。</span>
            X(target);
            H(target);
        } apply {
            <span class="hljs-comment">// 应用标记oracle；由于目标处于|-⟩状态，</span>
            <span class="hljs-comment">// 如果寄存器满足oracle条件，则翻转目标将对状态应用-1因子。</span>
            oracle(register, target);
        }
        <span class="hljs-comment">//我们把目标放回|0⟩这样我们就可以把它放回去了。</span>
    }
}
</div></code></pre>
<h2 id="函数-applygroversalgorithmloop">函数 ApplyGroversAlgorithmLoop</h2>
<p>使用Grover算法迭代循环.</p>
<h3 id="输入-7">输入</h3>
<ul>
<li>
<p>register</p>
<p>量子比特的寄存器。</p>
</li>
<li>
<p>oracle</p>
<p><code>量子黑箱</code>定义了解决方案。</p>
</li>
<li>
<p>iterations</p>
<p>要尝试的迭代次数。</p>
</li>
</ul>
<h3 id="输出-3">输出</h3>
<p>单一实现Grover搜索算法。</p>
<h3 id="代码-8">代码</h3>
<pre><code class="language-javascript"><div>operation ApplyGroversAlgorithmLoop (register : Qubit[], 
    <span class="hljs-attr">oracle</span> : (<span class="hljs-function">(<span class="hljs-params">Qubit[], Qubit</span>) =&gt;</span> Unit is Adj), <span class="hljs-attr">iterations</span> : Int) : Unit {
    <span class="hljs-keyword">let</span> applyPhaseOracle = ApplyPhaseOracle(oracle, _);
    ApplyToEach(H, register);
    <span class="hljs-keyword">for</span> (_ <span class="hljs-keyword">in</span> <span class="hljs-number">1</span> .. iterations) {
        applyPhaseOracle(register);
        within {
            ApplyToEachA(H, register);
            ApplyToEachA(X, register);
        } apply {
            Controlled Z(Most(register), Tail(register));
        }
    }
}
</div></code></pre>
<h2 id="函数-niterations">函数 NIterations</h2>
<p>估计求解所需的迭代次数。</p>
<h3 id="输入-8">输入</h3>
<ul>
<li>
<p>nQubits</p>
<p>正在使用的量子位数。</p>
</li>
</ul>
<h3 id="评述">评述</h3>
<p>对于振幅放大问题，只有一个正确的解决方案，这是正确的，但需要在有多个解决方案时进行调整。</p>
<h3 id="代码-9">代码</h3>
<pre><code class="language-javascript"><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">NIterations</span>(<span class="hljs-params">nQubits : Int</span>) : <span class="hljs-title">Int</span> </span>{
    <span class="hljs-keyword">let</span> nItems = <span class="hljs-number">1</span> &lt;&lt;&lt; nQubits; <span class="hljs-comment">// 2^numQubits</span>
    <span class="hljs-comment">// 计算迭代次数</span>
    <span class="hljs-keyword">let</span> angle = ArcSin(<span class="hljs-number">1.</span> / Sqrt(IntAsDouble(nItems)));
    <span class="hljs-keyword">let</span> nIterations = Round(<span class="hljs-number">0.25</span> * PI() / angle - <span class="hljs-number">0.5</span>);
    <span class="hljs-keyword">return</span> nIterations;
}
</div></code></pre>
<h2 id="函数-issudokusolutionvalid">函数 IsSudokuSolutionValid</h2>
<p>检验填在空白位置的数字是否符合数独规则——满足行列的约束。</p>
<h3 id="输入-9">输入</h3>
<ul>
<li>
<p>size</p>
<p>数独大小。</p>
</li>
<li>
<p>edges</p>
<p>传统的边传递给图着色算法，在我们的例子中，是空的拼图方块。</p>
<p>这些边定义空单元格之间的任何“同一行”、“同一列”、“同一子网格”关系。</p>
</li>
<li>
<p>startingNumberConstraints</p>
<p>当我们开始的时候，由于数字已经在拼图中，对空格子的限制。</p>
</li>
<li>
<p>colors</p>
<p>每个空格的整数数组，即数独的解。</p>
</li>
</ul>
<h3 id="输出-4">输出</h3>
<p>如果符合数独规则，那么返回<code>真</code>。</p>
<h3 id="代码-10">代码</h3>
<pre><code class="language-javascript"><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">IsSudokuSolutionValid</span> (<span class="hljs-params">size : Int, edges : (Int, Int)[],startingNumberConstraints : (Int, Int)[], colors : Int[]</span>) : <span class="hljs-title">Bool</span> 
</span>{
    <span class="hljs-keyword">if</span> (Any(GreaterThanOrEqualI(_, size), colors)) { <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; }
    <span class="hljs-keyword">if</span> (Any(EqualI, edges)) { <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; }
    <span class="hljs-keyword">for</span> ((index, startingNumber) <span class="hljs-keyword">in</span> startingNumberConstraints) {
        <span class="hljs-keyword">if</span> (colors[index] == startingNumber) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
}
</div></code></pre>
<h1 id="summary-1">Summary</h1>
<p>Solve a Sudoku puzzle using Grover's algorithm.</p>
<h1 id="description">Description</h1>
<p>Sudoku is a graph coloring problem where graph edges must connect nodes of different colors. In our case, graph nodes are puzzle squares and colors are the Sudoku numbers. Graph edges are the constraints preventing squares from having the same values. To reduce the number of qubits needed, we only use qubits for empty squares.
We define the puzzle using 2 data structures:</p>
<ul>
<li>A list of edges connecting empty squares</li>
<li>A list of constraints on empty squares to the initial numbers
in the puzzle (starting numbers)
The code works for both 9x9 Sudoku puzzles, and 4x4 Sudoku puzzles.
This description will use a 4x4 puzzle to make it easier to understand.
The 4x4 puzzle is solved with number 0 to 3 instead of 1 to 4.
This is because we can encode 0-3 with 2 qubits.
However, the same rules apply:</li>
<li>The numbers 0 to 3 may only appear once per row, column and 2x2 sub squares.</li>
</ul>
<pre><code><code><div>    As an example              has solution
    _________________          _________________
    |   | 1 |   | 3 |          | 0 | 1 | 2 | 3 |  
    -----------------          -----------------
    | 2 |   |   | 1 |          | 2 | 3 | 0 | 1 |  
    -----------------          -----------------
    |   |   | 3 | 0 |          | 1 | 2 | 3 | 0 |  
    -----------------          -----------------
    | 3 |   | 1 |   |          | 3 | 0 | 1 | 2 |  
    -----------------          -----------------
   
</div></code></code></pre>
<p>In the above example, the edges/constraints for the top row are:</p>
<pre><code><code><div>   _________
  | ______   \                   _____   
  || __   \   \                  | __  \                        __
 _|||__\___\_ _\__         ______||__\___\__          _________|___\__ 
 |   | 1 |   | 3 |         |   | 1 |   | 3 |         |   | 1 |   | 3 | 
 -----------------         -----------------         -----------------

For the row above, the empty squares have indexes
_________________
| 0 |   | 1 |   |
-----------------
</div></code></code></pre>
<p>For this row the list of emptySquareEdges has only 1 entry:</p>
<p>emptySquareEdges = (0,1) i.e. empty square 0 can't have the same number as empty square 1.</p>
<p>The constraints on these empty squares to the starting numbers are:</p>
<p>startingNumberConstraints = (0,1)  (0,3)  (1,1)  (1,3)</p>
<p>This is a list of (empty square #, number it can't be).
i.e. empty square 0 can't have value 1 or 3, and empty square #1 can't have values 1 or 3.</p>
<h3 id="输入-10">输入</h3>
<ul>
<li>
<p>numVertices</p>
<p>空白方块数。</p>
</li>
<li>
<p>size</p>
<p>数独的大小。4个用于4x4格，9个用于9x9格。</p>
</li>
<li>
<p>emptySquareEdges</p>
<p>传统的边传递给图着色算法，在我们的例子中，是空的拼图方块。这些边定义空单元格之间的任何“同一行”、“同一列”、“同一子网格”关系。</p>
</li>
<li>
<p>startingNumberConstraints</p>
<p>当我们开始的时候，由于数字已经在数独中，对空方块的限制。</p>
</li>
</ul>
<h3 id="输出-5">输出</h3>
<p>一个包含结果和每个空正方形的数字数组的元组。</p>
<h3 id="提示-2">提示</h3>
<p>以下4x4数独的输入和输出是：</p>
<pre><code><code><div>    -----------------
    |   | 1 | 2 | 3 |         &lt;--- empty square #0
    -----------------
    | 2 |   | 0 | 1 |         &lt;--- empty square #1
    -----------------
    | 1 | 2 | 3 | 0 |
    -----------------
    | 3 |   | 1 | 2 |         &lt;--- empty square #2
    -----------------
</div></code></code></pre>
<p>emptySquareEdges = [(1, 0),(2, 1)] 空格 #0 不能够和 #1 有相同的颜色或者数字，空格 #1 不能够和 #2 有相同的颜色或者数字。</p>
<p>startingNumberConstraints = [(0, 2),(0, 1),(0, 3),(1, 1),(1, 2),(1, 0),(2, 1),(2, 2),(2, 3)]</p>
<p>空格 #0 不能够和 2,1,3 有相同的颜色或者数字或者在同一个2x2的方格中，空格 #1 不能够和 1,2,0 有相同的颜色或者数字或者在同一个2x2的方格中.</p>
<p>Results = [0,3,0] ，即空格 #0 = 0, 空格 #1 = 3, 空格 #2 = 0.</p>
<h3 id="代码-11">代码</h3>
<pre><code class="language-javascript"><div>operation SolvePuzzle(numVertices : Int, <span class="hljs-attr">size</span> : Int, <span class="hljs-attr">emptySquareEdges</span> : (Int, Int)[], 
    <span class="hljs-attr">startingNumberConstraints</span>: (Int, Int)[]) : (Bool, Int[]) {
    <span class="hljs-comment">// for size = 4x4 grid</span>
    <span class="hljs-keyword">let</span> bitsPerColor = size == <span class="hljs-number">9</span> ? <span class="hljs-number">4</span> | <span class="hljs-number">2</span>;
    mutable oracle = ApplyVertexColoringOracle(numVertices, bitsPerColor, emptySquareEdges, startingNumberConstraints, _, _);
    <span class="hljs-keyword">if</span> (size == <span class="hljs-number">9</span>) {
        <span class="hljs-comment">// Although we could use ApplyVertexColoringOracle for 9x9, we would</span>
        <span class="hljs-comment">// have to add restrictions on each color to not allow colors 8 </span>
        <span class="hljs-comment">// thru 15. This could be achieved by adding these to </span>
        <span class="hljs-comment">// startNumberConstraints. However, this did not scale well with </span>
        <span class="hljs-comment">// the simulator, and so instead we use </span>
        <span class="hljs-comment">// ApplyVertexColoringOracle4Bit9Color which has the 9 color </span>
        <span class="hljs-comment">// restriction built in.</span>
        set oracle = ApplyVertexColoringOracle4Bit9Color(numVertices, emptySquareEdges, startingNumberConstraints, _, _);
    } elif (size != <span class="hljs-number">4</span>) {
        fail $<span class="hljs-string">&quot;Cannot set size {size}: only a grid size of 4x4 or 9x9 is supported&quot;</span>;
    }
    <span class="hljs-keyword">let</span> numIterations = NIterations(bitsPerColor * numVertices);
    Message($<span class="hljs-string">&quot;Running Quantum test with #Vertex = {numVertices}&quot;</span>);
    Message($<span class="hljs-string">&quot;   Bits Per Color = {bitsPerColor}&quot;</span>);
    Message($<span class="hljs-string">&quot;   emptySquareEdges = {emptySquareEdges}&quot;</span>);
    Message($<span class="hljs-string">&quot;   startingNumberConstraints = {startingNumberConstraints}&quot;</span>);
    Message($<span class="hljs-string">&quot;   Estimated #iterations needed = {numIterations}&quot;</span>);
    Message($<span class="hljs-string">&quot;   Size of Sudoku grid = {size}x{size}&quot;</span>);
    <span class="hljs-keyword">let</span> coloring = FindColorsWithGrover(numVertices, bitsPerColor, numIterations, oracle);

    Message($<span class="hljs-string">&quot;Got Sudoku solution: {coloring}&quot;</span>);
    <span class="hljs-keyword">if</span> (IsSudokuSolutionValid(size, emptySquareEdges, startingNumberConstraints, coloring)) {
        Message($<span class="hljs-string">&quot;Got valid Sudoku solution: {coloring}&quot;</span>);
        <span class="hljs-keyword">return</span> (<span class="hljs-literal">true</span>, coloring);
    } <span class="hljs-keyword">else</span> {
        Message($<span class="hljs-string">&quot;Got invalid Sudoku solution: {coloring}&quot;</span>);
        <span class="hljs-keyword">return</span> (<span class="hljs-literal">false</span>, coloring);
    }
}
</div></code></pre>

    </body>
    </html>