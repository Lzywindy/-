<!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title>&#x6D4B;&#x91CF;&#x5BC4;&#x5B58;&#x5668;</title>
        <style>
</style>
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css" integrity="sha384-yFRtMMDnQtDRO8rLpMIKrtPCD5jdktao2TV19YiZYWMDkUR5GQZR/NOVTdquEx1j" crossorigin="anonymous">
<link href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css" rel="stylesheet" type="text/css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        <style>
.task-list-item { list-style-type: none; } .task-list-item-checkbox { margin-left: -20px; vertical-align: middle; }
</style>
        
        <script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script>
        
    </head>
    <body class="vscode-body vscode-light">
        <h1 id="测量寄存器">测量寄存器</h1>
<h2 id="函数-measurecolor">函数 MeasureColor</h2>
<p>测量量程寄存器的内容并将其转换为颜色（整数）。</p>
<h3 id="输入">输入</h3>
<ul>
<li>
<p>register</p>
<p>要测量的量子位寄存器。</p>
</li>
</ul>
<h3 id="代码">代码</h3>
<pre><code class="language-javascript"><div>operation MeasureColor (register : Qubit[]) : Int {
    <span class="hljs-keyword">return</span> MeasureInteger(LittleEndian(register));
}
</div></code></pre>
<h2 id="函数-measurecoloring">函数 MeasureColoring</h2>
<p>从寄存器中读取颜色。</p>
<h3 id="输入-1">输入</h3>
<ul>
<li>
<p>bitsPerColor</p>
<p>Number of bits per color.</p>
</li>
<li>
<p>register</p>
<p>The register of qubits to be measured.</p>
</li>
</ul>
<h3 id="代码-1">代码</h3>
<pre><code class="language-javascript"><div>operation MeasureColoring (bitsPerColor : Int, <span class="hljs-attr">register</span> : Qubit[]) : Int[] {
    <span class="hljs-keyword">let</span> numVertices = Length(register) / bitsPerColor;
    <span class="hljs-keyword">let</span> colorPartitions = Partitioned(ConstantArray(numVertices - <span class="hljs-number">1</span>, bitsPerColor), register);
    <span class="hljs-keyword">return</span> ForEach(MeasureColor, colorPartitions);
} 
</div></code></pre>
<h2 id="函数-applycolorequalityoracle">函数 ApplyColorEqualityOracle</h2>
<p>N位颜色等价oracle（无需额外的量子位）</p>
<h3 id="输入-2">输入</h3>
<ul>
<li>
<p>color0</p>
<p>第一个颜色。</p>
</li>
<li>
<p>color1</p>
<p>第二个颜色。</p>
</li>
</ul>
<h3 id="输出">输出</h3>
<p>两个颜色一样，则输出为1。</p>
<h3 id="代码-2">代码</h3>
<pre><code class="language-javascript"><div>operation ApplyColorEqualityOracle (color0 : Qubit[], <span class="hljs-attr">color1</span> : Qubit[], <span class="hljs-attr">target</span> : Qubit) : Unit is Adj+Ctl {
    within {
        <span class="hljs-keyword">for</span> ((q0, q1) <span class="hljs-keyword">in</span> Zip(color0, color1)) {
            <span class="hljs-comment">// compute XOR of q0 and q1 in place (storing it in q1).</span>
            CNOT(q0, q1);
        }
    } apply {
        <span class="hljs-comment">// if all XORs are 0, the bit strings are equal.</span>
        (ControlledOnInt(<span class="hljs-number">0</span>, X))(color1, target);
    }
}
</div></code></pre>
<h2 id="函数-applyvertexcoloringoracle">函数 ApplyVertexColoringOracle</h2>
<p>Oracle for verifying vertex coloring, including color constraints from
non qubit vertices.</p>
<h1 id="input">Input</h1>
<h2 id="numvertices">numVertices</h2>
<p>The number of vertices in the graph.</p>
<h2 id="bitspercolor">bitsPerColor</h2>
<p>The bits per color e.g. 2 bits per color allows for 4 colors.</p>
<h2 id="edges">edges</h2>
<p>The array of (Vertex#,Vertex#) specifying the Vertices that can not be
the same color.</p>
<h2 id="startingcolorconstraints">startingColorConstraints</h2>
<p>The array of (Vertex#,Color) specifying the dissallowed colors for vertices.</p>
<h1 id="output">Output</h1>
<p>A unitary operation that applies <code>oracle</code> on the target register if the control
register state corresponds to the bit mask <code>bits</code>.</p>
<h1 id="example">Example</h1>
<p>Consider the following 4x4 Sudoku puzzle</p>
<pre><code><code><div>    -----------------
    |   |   | 2 | 3 |
    -----------------
    |   |   | 0 | 1 |
    -----------------
    | 1 | 2 | 3 | 0 |
    -----------------
    | 3 | 0 | 1 | 2 |
    -----------------
</div></code></code></pre>
<p>The challenge is to fill the empty squares with numbers 0 to 3
that are unique in row, column and the top left 2x2 square.
This is a graph coloring problem where the colors are 0 to 3
and the empty cells are the vertices. The vertices can be defined as:</p>
<pre><code><code><div>    -----------------
    | 0 | 1 |   |   |
    -----------------
    | 2 | 3 |   |   |
    -----------------
    |   |   |   |   |
    -----------------
    |   |   |   |   |
    -----------------

The graph is

 0---1
 | X |
 1---2
</div></code></code></pre>
<p>i.e. every vertex is connected to each other.
Additionally, we require that:</p>
<ul>
<li>vertices 0 and 1 do not get colors 2 and 3.</li>
<li>vertices 2 and 3 do not get colors 3 and 0.</li>
<li>vertices 0 and 2 do not get colors 1 and 3.</li>
<li>vertices 1 and 3 do not get colors 2 and 0.
This results in edges (vertices that can not be same color):
<code>edges = [(1, 0),(2, 0),(3, 0),(3, 1),(3, 2)]</code>
This is saying that vertex 1 can not have same color as vertex 0 etc.</li>
</ul>
<p>and startingColorConstraints = [(0, 1),(0, 3),(0, 2),(1, 2),(1, 0),
(1, 3),(2, 1),(2, 3),(2, 0),(3, 2),(3, 0),(3, 1)]</p>
<p>This is saying that vertex 0 is not allowed to have values 1,3,2
and vertex 1 is not allowed to have values 2,0,3
and vertex 2 is not allowed to have values 1,3,0
and vertex 3 is not allowed to have values 2,0,1</p>
<p>A valid graph coloring solution is: [0,1,2,3] i.e. vextex 0 has color 0, vertex 1 has color 1 etc.</p>
<h3 id="代码-3">代码</h3>
<pre><code class="language-javascript"><div>operation ApplyVertexColoringOracle (numVertices : Int, <span class="hljs-attr">bitsPerColor</span> : Int, <span class="hljs-attr">edges</span> : (Int, Int)[],  
    <span class="hljs-attr">startingColorConstraints</span> : (Int, Int)[], 
    <span class="hljs-attr">colorsRegister</span> : Qubit[], 
    <span class="hljs-attr">target</span> : Qubit) : Unit is Adj+Ctl {
    <span class="hljs-keyword">let</span> nEdges = Length(edges);
    <span class="hljs-keyword">let</span> nStartingColorConstraints = Length(startingColorConstraints);
    <span class="hljs-comment">// we are looking for a solution that:</span>
    <span class="hljs-comment">// (a) has no edge with same color at both ends and </span>
    <span class="hljs-comment">// (b) has no Vertex with a color that violates the starting color constraints.</span>
    using ((edgeConflictQubits, startingColorConflictQubits) = (Qubit[nEdges], Qubit[nStartingColorConstraints])) {
        within {
            ConstrainByEdgeAndStartingColors(colorsRegister, edges, startingColorConstraints, edgeConflictQubits, startingColorConflictQubits, bitsPerColor);
        } apply {
            <span class="hljs-comment">// If there are no conflicts (all qubits are in 0 state), the vertex coloring is valid.</span>
            (ControlledOnInt(<span class="hljs-number">0</span>, X))(edgeConflictQubits + startingColorConflictQubits, target);
        }
    }
}

operation ConstrainByEdgeAndStartingColors (colorsRegister : Qubit[], <span class="hljs-attr">edges</span> : (Int, Int)[], <span class="hljs-attr">startingColorConstraints</span> : (Int, Int)[],
    <span class="hljs-attr">edgeConflictQubits</span> : Qubit[], <span class="hljs-attr">startingColorConflictQubits</span> : Qubit[], <span class="hljs-attr">bitsPerColor</span>: Int): Unit is Adj+Ctl {
    <span class="hljs-keyword">for</span> (((start, end), conflictQubit) <span class="hljs-keyword">in</span> Zip(edges, edgeConflictQubits)) {
        <span class="hljs-comment">// Check that endpoints of the edge have different colors:</span>
        <span class="hljs-comment">// apply ColorEqualityOracle_Nbit oracle; </span>
        <span class="hljs-comment">// if the colors are the same the result will be 1, indicating a conflict</span>
        ApplyColorEqualityOracle(
            colorsRegister[start * bitsPerColor .. (start + <span class="hljs-number">1</span>) * bitsPerColor - <span class="hljs-number">1</span>], colorsRegister[end * bitsPerColor .. (end + <span class="hljs-number">1</span>) * bitsPerColor - <span class="hljs-number">1</span>], conflictQubit);
    }
    <span class="hljs-keyword">for</span> (((cell, value), conflictQubit) <span class="hljs-keyword">in</span> 
        Zip(startingColorConstraints, startingColorConflictQubits)) {
        <span class="hljs-comment">// Check that cell does not clash with starting colors.</span>
        (ControlledOnInt(value, X))(colorsRegister[
            cell * bitsPerColor .. (cell + <span class="hljs-number">1</span>) * bitsPerColor - <span class="hljs-number">1</span>], conflictQubit);
    }

}
</div></code></pre>
<h1 id="summary">Summary</h1>
<p>Oracle for verifying vertex coloring, including color constraints
from non qubit vertices. This is the same as ApplyVertexColoringOracle,
but hardcoded to 4 bits per color and restriction that colors are
limited to 0 to 8.</p>
<h1 id="input-1">Input</h1>
<h2 id="numvertices-1">numVertices</h2>
<p>The number of vertices in the graph.</p>
<h2 id="edges-1">edges</h2>
<p>The array of (Vertex#,Vertex#) specifying the Vertices that can not
be the same color.</p>
<h2 id="startingcolorconstraints-1">startingColorConstraints</h2>
<p>The array of (Vertex#,Color) specifying the dissallowed colors for vertices.</p>
<h2 id="colorsregister">colorsRegister</h2>
<p>The color register.</p>
<h2 id="target">target</h2>
<p>The target of the operation.</p>
<h1 id="output-1">Output</h1>
<p>A unitary operation that applies <code>oracle</code> on the target register if the control
register state corresponds to the bit mask <code>bits</code>.</p>
<h1 id="example-1">Example</h1>
<p>Consider the following 9x9 Sudoku puzzle:</p>
<pre><code><code><div>   -------------------------------------
   |   | 6 | 2 | 7 | 8 | 3 | 4 | 0 | 1 |
   -------------------------------------
   | 8 |   | 1 | 6 | 2 | 4 | 3 | 7 | 5 |
   -------------------------------------
   | 7 | 3 | 4 | 5 | 0 | 1 | 8 | 6 | 2 |
   -------------------------------------
   | 6 | 8 | 7 | 1 | 5 | 0 | 2 | 4 | 3 |
   -------------------------------------
   | 4 | 1 | 5 | 3 | 6 | 2 | 7 | 8 | 0 |
   -------------------------------------
   | 0 | 2 | 3 | 4 | 7 | 8 | 1 | 5 | 6 |
   -------------------------------------
   | 3 | 5 | 8 | 0 | 1 | 7 | 6 | 2 | 4 |
   -------------------------------------
   | 1 | 7 | 6 | 2 | 4 | 5 | 0 | 3 | 8 |
   -------------------------------------
   | 2 | 4 | 0 | 8 | 3 | 6 | 5 | 1 | 7 |
   -------------------------------------
</div></code></code></pre>
<p>The challenge is to fill the empty squares with numbers 0 to 8
that are unique in row, column and the top left 3x3 square
This is a graph coloring problem where the colors are 0 to 8
and the empty cells are the vertices. The vertices can be defined as</p>
<pre><code><code><div>    -----------------
    | 0 |   |   |   | ...
    -----------------
    |   | 1 |   |   | ...
    -----------------
    |   |   |   |   | ...
    ...
</div></code></code></pre>
<p>The graph is</p>
<pre><code><code><div>    0---1 
</div></code></code></pre>
<p>Additionally, we also require that</p>
<ul>
<li>vertex 0 can not have value 6,2,7,8,3,4,0,1 (row constraint)
or value 8,7,6,4,0,3,1,2 (col constraint)</li>
<li>vertex 1 can not value 8,1,6,2,4,3,7,5 (row constraint)
or value 6,3,8,1,2,5,7,4 (col constraint)
This results in edges (vertices that can not be same color)
edges = [(1, 0)]
This is saying that vertex 1 can not have same color as vertex 0
and startingColorConstraints = [(0, 8),(0, 7),(0, 6),(0, 4),(0, 0),(0, 3),
(0, 1),(0, 2),(1, 6),(1, 3),(1, 8),(1, 1),(1, 2),(1, 5),(1, 7),(1, 4)]
The colors found must be from 0 to 8, which requires 4 bits per color.
A valid graph coloring solution is: [5,0]
i.e. vextex 0 has color 5, vertex 1 has color 0.</li>
</ul>
<h3 id="代码-4">代码</h3>
<pre><code class="language-javascript"><div>operation ApplyVertexColoringOracle4Bit9Color (numVertices : Int, <span class="hljs-attr">edges</span> : (Int, Int)[],  <span class="hljs-attr">startingColorConstraints</span> : (Int, Int)[], <span class="hljs-attr">colorsRegister</span> : Qubit[], <span class="hljs-attr">target</span> : Qubit) : Unit is Adj+Ctl {
    <span class="hljs-keyword">let</span> nEdges = Length(edges);
    <span class="hljs-keyword">let</span> bitsPerColor = <span class="hljs-number">4</span>; <span class="hljs-comment">// 4 bits per color</span>
    <span class="hljs-keyword">let</span> nStartingColorConstraints = Length(startingColorConstraints);
    <span class="hljs-comment">// we are looking for a solution that:</span>
    <span class="hljs-comment">// (a) has no edge with same color at both ends and </span>
    <span class="hljs-comment">// (b) has no Vertex with a color that violates the starting color constraints.</span>
    using ((edgeConflictQubits, startingColorConflictQubits, vertexColorConflictQubits) = 
        (Qubit[nEdges], Qubit[nStartingColorConstraints], Qubit[numVertices])) {
        within {
            ConstrainByEdgeAndStartingColors(colorsRegister, edges, startingColorConstraints, 
                edgeConflictQubits, startingColorConflictQubits, bitsPerColor);
            <span class="hljs-keyword">let</span> zippedColorAndConfictQubit = Zip(
                Partitioned(ConstantArray(numVertices, bitsPerColor), colorsRegister),
                vertexColorConflictQubits);
            <span class="hljs-keyword">for</span> ((color, conflictQubit) <span class="hljs-keyword">in</span> zippedColorAndConfictQubit) {
                <span class="hljs-comment">// Only allow colors from 0 to 8 i.e. if bit #3 = 1, then bits 2..0 must be 000.</span>
                using (tempQubit = Qubit()) {
                    within {
                        ApplyOrOracle(color[<span class="hljs-number">0</span> .. <span class="hljs-number">2</span>], tempQubit);
                    } apply{
                        <span class="hljs-comment">// AND color&#x27;s most significant bit with OR of least significant bits. </span>
                        <span class="hljs-comment">// This will set conflictQubit to 1 if color &gt; 8.</span>
                        CCNOT(color[<span class="hljs-number">3</span>], tempQubit, conflictQubit);
                    }
                }
            }
        } apply {
            <span class="hljs-comment">// If there are no conflicts (all qubits are in 0 state), the vertex coloring is valid.</span>
            (ControlledOnInt(<span class="hljs-number">0</span>, X))(edgeConflictQubits + startingColorConflictQubits + vertexColorConflictQubits, target);
        }
    }
}
</div></code></pre>
<h1 id="summary-1">Summary</h1>
<p>OR oracle for an arbitrary number of qubits in query register.</p>
<h1 id="inputs">Inputs</h1>
<h2 id="queryregister">queryRegister</h2>
<p>Qubit register to query.</p>
<h2 id="target-1">target</h2>
<p>Target qubit for storing oracle result.</p>
<h3 id="代码-5">代码</h3>
<pre><code class="language-javascript"><div>operation ApplyOrOracle (queryRegister : Qubit[], <span class="hljs-attr">target</span> : Qubit) : Unit is Adj {        
    <span class="hljs-comment">// x₀ ∨ x₁ = ¬ (¬x₀ ∧ ¬x₁)</span>
    <span class="hljs-comment">// First, flip target if both qubits are in |0⟩ state.</span>
    (ControlledOnInt(<span class="hljs-number">0</span>, X))(queryRegister, target);
    <span class="hljs-comment">// Then flip target again to get negation.</span>
    X(target);
}
</div></code></pre>
<h1 id="summary-2">Summary</h1>
<p>Using Grover's search to find vertex coloring.</p>
<h1 id="input-2">Input</h1>
<h2 id="numvertices-2">numVertices</h2>
<p>The number of Vertices in the graph.</p>
<h2 id="bitspercolor-1">bitsPerColor</h2>
<p>The number of bits per color.</p>
<h2 id="maxiterations">maxIterations</h2>
<p>An estimate of the maximum iterations needed.</p>
<h2 id="oracle">oracle</h2>
<p>The Oracle used to find solution.</p>
<h1 id="output-2">Output</h1>
<p>Int Array giving the color of each vertex.</p>
<h1 id="remarks">Remarks</h1>
<p>See [<a href="https://github.com/microsoft/QuantumKatas/tree/main/SolveSATWithGrover">https://github.com/microsoft/QuantumKatas/tree/main/SolveSATWithGrover</a>]
for original implementation in SolveSATWithGrover Kata.</p>
<h3 id="代码-6">代码</h3>
<pre><code class="language-javascript"><div>operation FindColorsWithGrover (numVertices : Int, <span class="hljs-attr">bitsPerColor</span> : Int, <span class="hljs-attr">maxIterations</span> : Int, 
    <span class="hljs-attr">oracle</span> : (<span class="hljs-function">(<span class="hljs-params">Qubit[], Qubit</span>) =&gt;</span> Unit is Adj)) : Int[] {
    <span class="hljs-comment">// This task is similar to task 2.2 from SolveSATWithGrover kata, </span>
    <span class="hljs-comment">// but the percentage of correct solutions is potentially higher.</span>
    mutable coloring = <span class="hljs-keyword">new</span> Int[numVertices];

    <span class="hljs-comment">// Note that coloring register has the number of qubits that is </span>
    <span class="hljs-comment">// twice the number of vertices (bitsPerColor qubits per vertex).</span>
    using ((register, output) = (Qubit[bitsPerColor * numVertices], Qubit())) {
        mutable correct = <span class="hljs-literal">false</span>;
        mutable iter = <span class="hljs-number">1</span>;
        <span class="hljs-comment">// Try for one iteration, if it fails, try again for one more iteration and repeat until maxIterations is reached.</span>
        repeat {
            Message($<span class="hljs-string">&quot;Trying search with {iter} iterations...&quot;</span>);
            ApplyGroversAlgorithmLoop(register, oracle, iter);
            <span class="hljs-keyword">let</span> res = MultiM(register);
            <span class="hljs-comment">// to check whether the result is correct, apply the oracle to the </span>
            <span class="hljs-comment">// register plus auxiliary after measurement.</span>
            oracle(register, output);
            <span class="hljs-keyword">if</span> (MResetZ(output) == One) {
                set correct = <span class="hljs-literal">true</span>;
                <span class="hljs-comment">// Read off coloring.</span>
                set coloring = MeasureColoring(bitsPerColor, register);
            }
            ResetAll(register);
        } until (correct or iter &gt; maxIterations)  
        fixup {
            set iter += <span class="hljs-number">1</span>;
        }
        <span class="hljs-keyword">if</span> (not correct) {
            fail <span class="hljs-string">&quot;Failed to find a coloring.&quot;</span>;
        }
    }
    <span class="hljs-keyword">return</span> coloring;
}
</div></code></pre>
<h1 id="summary-3">Summary</h1>
<p>Grover algorithm loop</p>
<h1 id="input-3">Input</h1>
<h2 id="oracle-1">oracle</h2>
<p>The oracle which will mark the valid solutions.</p>
<h1 id="remarks-1">Remarks</h1>
<p>See [<a href="https://github.com/microsoft/QuantumKatas/tree/main/SolveSATWithGrover">https://github.com/microsoft/QuantumKatas/tree/main/SolveSATWithGrover</a>]
for the original implementation from the SolveSATWithGrover kata.</p>
<h3 id="代码-7">代码</h3>
<pre><code class="language-javascript"><div>operation ApplyPhaseOracle (oracle : (<span class="hljs-function">(<span class="hljs-params">Qubit[], Qubit</span>) =&gt;</span> Unit is Adj), <span class="hljs-attr">register</span> : Qubit[]) : Unit is Adj {

    using (target = Qubit()) {
        within {
            <span class="hljs-comment">// Put the target into the |-⟩ state.</span>
            X(target);
            H(target);
        } apply {
            <span class="hljs-comment">// Apply the marking oracle; since the target is in the |-⟩ state,</span>
            <span class="hljs-comment">// flipping the target if the register satisfies the oracle condition </span>
            <span class="hljs-comment">// will apply a -1 factor to the state.</span>
            oracle(register, target);
        }
        <span class="hljs-comment">// We put the target back into |0⟩ so we can return it.</span>
    }
}
</div></code></pre>
<h1 id="summary-4">Summary</h1>
<p>Grover's Algorithm loop.</p>
<h1 id="input-4">Input</h1>
<h2 id="register">register</h2>
<p>The register of qubits.</p>
<h2 id="oracle-2">oracle</h2>
<p>The oracle defining the solution we want.</p>
<h2 id="iterations">iterations</h2>
<p>The number of iterations to try.</p>
<h1 id="output-3">Output</h1>
<p>Unitary implementing Grover's search algorithm.</p>
<h3 id="代码-8">代码</h3>
<pre><code class="language-javascript"><div>operation ApplyGroversAlgorithmLoop (register : Qubit[], 
    <span class="hljs-attr">oracle</span> : (<span class="hljs-function">(<span class="hljs-params">Qubit[], Qubit</span>) =&gt;</span> Unit is Adj), <span class="hljs-attr">iterations</span> : Int) : Unit {
    <span class="hljs-keyword">let</span> applyPhaseOracle = ApplyPhaseOracle(oracle, _);
    ApplyToEach(H, register);
        
    <span class="hljs-keyword">for</span> (_ <span class="hljs-keyword">in</span> <span class="hljs-number">1</span> .. iterations) {
        applyPhaseOracle(register);
        within {
            ApplyToEachA(H, register);
            ApplyToEachA(X, register);
        } apply {
            Controlled Z(Most(register), Tail(register));
        }
    }
}
</div></code></pre>
<h1 id="summary-5">Summary</h1>
<p>Solve a Sudoku puzzle using Grover's algorithm.</p>
<h1 id="description">Description</h1>
<p>Sudoku is a graph coloring problem where graph edges must connect nodes of different colors. In our case, graph nodes are puzzle squares and colors are the Sudoku numbers. Graph edges are the constraints preventing squares from having the same values. To reduce the number of qubits needed, we only use qubits for empty squares.
We define the puzzle using 2 data structures:</p>
<ul>
<li>A list of edges connecting empty squares</li>
<li>A list of constraints on empty squares to the initial numbers
in the puzzle (starting numbers)
The code works for both 9x9 Sudoku puzzles, and 4x4 Sudoku puzzles.
This description will use a 4x4 puzzle to make it easier to understand.
The 4x4 puzzle is solved with number 0 to 3 instead of 1 to 4.
This is because we can encode 0-3 with 2 qubits.
However, the same rules apply:</li>
<li>The numbers 0 to 3 may only appear once per row, column and 2x2 sub squares.</li>
</ul>
<pre><code><code><div>    As an example              has solution
    _________________          _________________
    |   | 1 |   | 3 |          | 0 | 1 | 2 | 3 |  
    -----------------          -----------------
    | 2 |   |   | 1 |          | 2 | 3 | 0 | 1 |  
    -----------------          -----------------
    |   |   | 3 | 0 |          | 1 | 2 | 3 | 0 |  
    -----------------          -----------------
    | 3 |   | 1 |   |          | 3 | 0 | 1 | 2 |  
    -----------------          -----------------
   
</div></code></code></pre>
<p>In the above example, the edges/constraints for the top row are:</p>
<pre><code><code><div>   _________
  | ______   \                   _____   
  || __   \   \                  | __  \                        __
 _|||__\___\_ _\__         ______||__\___\__          _________|___\__ 
 |   | 1 |   | 3 |         |   | 1 |   | 3 |         |   | 1 |   | 3 | 
 -----------------         -----------------         -----------------

For the row above, the empty squares have indexes
_________________
| 0 |   | 1 |   |
-----------------
</div></code></code></pre>
<p>For this row the list of emptySquareEdges has only 1 entry:</p>
<p>emptySquareEdges = (0,1) i.e. empty square 0 can't have the same number as empty square 1.</p>
<p>The constraints on these empty squares to the starting numbers are:</p>
<p>startingNumberConstraints = (0,1)  (0,3)  (1,1)  (1,3)</p>
<p>This is a list of (empty square #, number it can't be).
i.e. empty square 0 can't have value 1 or 3, and empty square #1 can't have values 1 or 3.</p>
<h1 id="input-5">Input</h1>
<h2 id="numvertices-3">numVertices</h2>
<p>number of blank squares.</p>
<h2 id="size">size</h2>
<p>The size of the puzzle. 4 for 4x4 grid, 9 for 9x9 grid.</p>
<h2 id="emptysquareedges">emptySquareEdges</h2>
<p>The traditional edges passed to the graph coloring algorithm which,
in our case, are empty puzzle squares.
These edges define any &quot;same row&quot;, &quot;same column&quot;, &quot;same sub-grid&quot;
relationships between empty cells.
Look at the <a href="http://README.html">README.md</a> sample output to see examples of what this is
for different sample puzzles.</p>
<h2 id="startingnumberconstraints">startingNumberConstraints</h2>
<p>The constraints on the empty squares due to numbers already in the
puzzle when we start.
Look at the <a href="http://README.html">README.md</a> sample output to see examples of what this is
for different sample puzzles.</p>
<h1 id="output-4">Output</h1>
<p>A tuple with Result and the array of numbers for each empty square.
Look at the <a href="http://README.html">README.md</a> sample output to see examples of what this is
for different sample puzzles.</p>
<h1 id="remarks-2">Remarks</h1>
<p>The inputs and outputs for the following 4x4 puzzle are:</p>
<pre><code><code><div>    -----------------
    |   | 1 | 2 | 3 |         &lt;--- empty square #0
    -----------------
    | 2 |   | 0 | 1 |         &lt;--- empty square #1
    -----------------
    | 1 | 2 | 3 | 0 |
    -----------------
    | 3 |   | 1 | 2 |         &lt;--- empty square #2
    -----------------
</div></code></code></pre>
<p>emptySquareEdges = [(1, 0),(2, 1)] empty square #0 can not have the same color/number as empty call #1.</p>
<p>empty square #1 and #2 can not have the same color/number (same column).</p>
<p>startingNumberConstraints = [(0, 2),(0, 1),(0, 3),(1, 1),(1, 2),(1, 0),(2, 1),(2, 2),(2, 3)]</p>
<p>empty square #0 can not have values 2,1,3 because same row/column/2x2grid.</p>
<p>empty square #1 can not have values 1,2,0 because same row/column/2x2grid.</p>
<p>Results = [0,3,0] i.e. Empty Square #0 = 0, Empty Square #1 = 3, Empty Square #2 = 0.</p>
<h3 id="代码-9">代码</h3>
<pre><code class="language-javascript"><div>operation SolvePuzzle(numVertices : Int, <span class="hljs-attr">size</span> : Int, <span class="hljs-attr">emptySquareEdges</span> : (Int, Int)[], 
    <span class="hljs-attr">startingNumberConstraints</span>: (Int, Int)[]) : (Bool, Int[]) {
    <span class="hljs-comment">// for size = 4x4 grid</span>
    <span class="hljs-keyword">let</span> bitsPerColor = size == <span class="hljs-number">9</span> ? <span class="hljs-number">4</span> | <span class="hljs-number">2</span>;
    mutable oracle = ApplyVertexColoringOracle(numVertices, bitsPerColor, emptySquareEdges, startingNumberConstraints, _, _);
    <span class="hljs-keyword">if</span> (size == <span class="hljs-number">9</span>) {
        <span class="hljs-comment">// Although we could use ApplyVertexColoringOracle for 9x9, we would</span>
        <span class="hljs-comment">// have to add restrictions on each color to not allow colors 8 </span>
        <span class="hljs-comment">// thru 15. This could be achieved by adding these to </span>
        <span class="hljs-comment">// startNumberConstraints. However, this did not scale well with </span>
        <span class="hljs-comment">// the simulator, and so instead we use </span>
        <span class="hljs-comment">// ApplyVertexColoringOracle4Bit9Color which has the 9 color </span>
        <span class="hljs-comment">// restriction built in.</span>
        set oracle = ApplyVertexColoringOracle4Bit9Color(numVertices, emptySquareEdges, startingNumberConstraints, _, _);
    } elif (size != <span class="hljs-number">4</span>) {
        fail $<span class="hljs-string">&quot;Cannot set size {size}: only a grid size of 4x4 or 9x9 is supported&quot;</span>;
    }
    <span class="hljs-keyword">let</span> numIterations = NIterations(bitsPerColor * numVertices);
    Message($<span class="hljs-string">&quot;Running Quantum test with #Vertex = {numVertices}&quot;</span>);
    Message($<span class="hljs-string">&quot;   Bits Per Color = {bitsPerColor}&quot;</span>);
    Message($<span class="hljs-string">&quot;   emptySquareEdges = {emptySquareEdges}&quot;</span>);
    Message($<span class="hljs-string">&quot;   startingNumberConstraints = {startingNumberConstraints}&quot;</span>);
    Message($<span class="hljs-string">&quot;   Estimated #iterations needed = {numIterations}&quot;</span>);
    Message($<span class="hljs-string">&quot;   Size of Sudoku grid = {size}x{size}&quot;</span>);
    <span class="hljs-keyword">let</span> coloring = FindColorsWithGrover(numVertices, bitsPerColor, numIterations, oracle);

    Message($<span class="hljs-string">&quot;Got Sudoku solution: {coloring}&quot;</span>);
    <span class="hljs-keyword">if</span> (IsSudokuSolutionValid(size, emptySquareEdges, startingNumberConstraints, coloring)) {
        Message($<span class="hljs-string">&quot;Got valid Sudoku solution: {coloring}&quot;</span>);
        <span class="hljs-keyword">return</span> (<span class="hljs-literal">true</span>, coloring);
    } <span class="hljs-keyword">else</span> {
        Message($<span class="hljs-string">&quot;Got invalid Sudoku solution: {coloring}&quot;</span>);
        <span class="hljs-keyword">return</span> (<span class="hljs-literal">false</span>, coloring);
    }
}
</div></code></pre>
<h2 id="函数-niterations">函数 NIterations</h2>
<p>Estimate the number of interations required for solution.</p>
<h3 id="输入-3">输入</h3>
<ul>
<li>
<p>nQubits</p>
<p>The number of qubits being used.</p>
</li>
</ul>
<h3 id="评述">评述</h3>
<p>This is correct for an amplitude amplification problem with a single correct solution, but would need to be adapted when there are multiple solutions</p>
<h3 id="代码-10">代码</h3>
<pre><code class="language-javascript"><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">NIterations</span>(<span class="hljs-params">nQubits : Int</span>) : <span class="hljs-title">Int</span> </span>{
    <span class="hljs-keyword">let</span> nItems = <span class="hljs-number">1</span> &lt;&lt;&lt; nQubits; <span class="hljs-comment">// 2^numQubits</span>
    <span class="hljs-comment">// compute number of iterations:</span>
    <span class="hljs-keyword">let</span> angle = ArcSin(<span class="hljs-number">1.</span> / Sqrt(IntAsDouble(nItems)));
    <span class="hljs-keyword">let</span> nIterations = Round(<span class="hljs-number">0.25</span> * PI() / angle - <span class="hljs-number">0.5</span>);
    <span class="hljs-keyword">return</span> nIterations;
}
</div></code></pre>
<h2 id="函数-issudokusolutionvalid">函数 IsSudokuSolutionValid</h2>
<p>Check if the colors/numbers found for each empty square are in the correct range (e.g. &lt;9 for a 9x9 puzzle) and satisfy all edge/starting number constraints.</p>
<h3 id="input-6">Input</h3>
<ul>
<li>
<p>size</p>
<p>The size of the puzzle. 4 for 4x4 grid, 9 for 9x9 grid.</p>
</li>
<li>
<p>edges</p>
<p>The traditional edges passed to the graph coloring algorithm which, in our case, are empty puzzle squares.</p>
<p>These edges define any &quot;same row&quot;, &quot;same column&quot;, &quot;same sub-grid&quot; relationships between empty cells.</p>
</li>
<li>
<p>startingNumberConstraints</p>
<p>The constraints on the empty squares due to numbers already in the puzzle when we start.</p>
</li>
<li>
<p>colors</p>
<p>An Int array of numbers for each empty square i.e. the puzzle solution.</p>
</li>
</ul>
<h3 id="output-5">Output</h3>
<p>A boolean value of true if the colors found satisfy all the solution requirements.</p>
<h3 id="代码-11">代码</h3>
<pre><code class="language-javascript"><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">IsSudokuSolutionValid</span> (<span class="hljs-params">size : Int, edges : (Int, Int)[], 
    startingNumberConstraints : (Int, Int)[], colors : Int[]</span>) : <span class="hljs-title">Bool</span> </span>{
    <span class="hljs-keyword">if</span> (Any(GreaterThanOrEqualI(_, size), colors)) { <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; }
    <span class="hljs-keyword">if</span> (Any(EqualI, edges)) { <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; }
    <span class="hljs-keyword">for</span> ((index, startingNumber) <span class="hljs-keyword">in</span> startingNumberConstraints) {
        <span class="hljs-keyword">if</span> (colors[index] == startingNumber) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
}
</div></code></pre>

    </body>
    </html>